---
title: "Modele Nieparametryczne"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: "flatly"
    code_folding: hide
---

```{r setup, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Inicjalizacja bibliotek

library(rpart)
library(rpart.plot)
library(VIM)
library("dplyr")
library("tidyr")
library("lubridate")
library("ggplot2")
# Ładowanie danych

load(file="dane_zaliczenie.RData")
```



## Tworzenie nowych zmiennych
```{r}
proba_uczaca$day_of_week_createtime <- weekdays(proba_uczaca$createtime, abbreviate = FALSE)
proba_uczaca$month_createtime <- months(proba_uczaca$createtime, abbreviate = FALSE)
proba_uczaca$year_createtime <- year(proba_uczaca$createtime)

proba_uczaca$expirydate <- as.integer(paste0(proba_uczaca$expiryyear,proba_uczaca$expirymonth))
```

## Surowy zbiór danych
```{r data_presetation}
create_plot <- function(variable) {
  ggplot(proba_uczaca , aes(x=factor(variable), fill=factor(variable))) + 
    geom_bar() +
    theme(legend.position="none",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  
}
create_plot(proba_uczaca$expiryyear)
table(proba_uczaca$expiryyear)

create_plot(proba_uczaca$issuer)
table(proba_uczaca$issuer)

create_plot(proba_uczaca$mccname)
table(proba_uczaca$mccname)

create_plot(proba_uczaca$recurringaction)
table(proba_uczaca$recurringaction)

create_plot(proba_uczaca$type)
table(proba_uczaca$type)

create_plot(proba_uczaca$description)
table(proba_uczaca$description)

create_plot(proba_uczaca$level)
table(proba_uczaca$level)

create_plot(proba_uczaca$status)
table(proba_uczaca$status)

create_plot(proba_uczaca$countrycode)
table(proba_uczaca$countrycode)

create_plot(proba_uczaca$expirymonth)
table(proba_uczaca$expirymonth)

create_plot(proba_uczaca$listtype)
table(proba_uczaca$listtype)

create_plot(proba_uczaca$acquirerconnectionmethod)
table(proba_uczaca$acquirerconnectionmethod)

create_plot(proba_uczaca$day_of_week_createtime)
table(proba_uczaca$day_of_week_createtime)

create_plot(proba_uczaca$month_createtime)
table(proba_uczaca$month_createtime)

create_plot(proba_uczaca$expirydate)
table(proba_uczaca$expirydate)

create_plot(proba_uczaca$year_createtime)
table(proba_uczaca$year_createtime)

```


## Przedstawienie brakujących danych
```{r missing data}
missing_data_plot <- aggr(proba_uczaca, col=c('forestgreen','firebrick1'),
                          numbers=TRUE, sortVars=TRUE,
                          labels=names(proba_uczaca), cex.axis=.7,
                          gap=3, ylab=c("Missing data","Pattern"))
```

# Imputacja braków danych w zmiennych `browseragent` oraz `initialtransaction_id`
```{r}
for (i in 1:nrow(proba_uczaca)){
  if (is.na(proba_uczaca[i,]$browseragent) == TRUE){
    proba_uczaca[i,]$browseragent <- proba_uczaca[which(proba_uczaca$id == proba_uczaca[i,]$initialtransaction_id),]$browseragent
  }
}

for (i in 1:nrow(proba_uczaca)){
  if (proba_uczaca[i,]$recurringaction != "AUTO"){
    proba_uczaca[i,]$initialtransaction_id <- proba_uczaca[i,]$id
  }
}
```

# Sprawdzanie braków danych po imputacji danych
```{r}
missing_data_plot <- aggr(proba_uczaca, col=c('forestgreen','firebrick1'),
                          numbers=TRUE, sortVars=TRUE,
                          labels=names(proba_uczaca), cex.axis=.7,
                          gap=3, ylab=c("Missing data","Pattern"))

```

# Usunięcie mieszanych kart w zmiennej `level` ze względu na niewielką ilośc rekordów z takimi wariantami oraz niemożliwości przydzielenia ich do jednej konkretnej kategorii
```{r remove all NA}
proba_uczaca <- proba_uczaca[!(proba_uczaca$level=="CLASSIC/GOLD" | proba_uczaca$level=="GOLD/PLATINUM" | proba_uczaca$level=="GOLD/STANDARD" | proba_uczaca$level=="INFINITE/SIGNATURE" | proba_uczaca$level=="STANDARD/GOLD") | proba_uczaca$level=="STANDARD/WORLD",]

```

# Recode wartości zmiennych
```{r recode, echo=FALSE}
proba_uczaca$description[is.na(proba_uczaca$description)] <- ""
#proba_uczaca$countrycode <- recode(proba_uczaca$countrycode, "PL"="PL", .default = "other")
proba_uczaca$status <- recode(proba_uczaca$status, "completed successfully"="sukces", .default = "porażka")
proba_uczaca$issuer <- recode(proba_uczaca$issuer, "VISA"="VISA", .default = "MASTERCARD")
proba_uczaca$recurringaction <- recode(proba_uczaca$recurringaction, "AUTO"="rekurencyjne", .default = "inicjalizujące")
# Usunięcie tranzakcji inicjalizujących z bazy
proba_uczaca <- proba_uczaca[!(proba_uczaca$recurringaction=="inicjalizujące"),]
proba_uczaca$level <- recode(proba_uczaca$level,
                             "WORLD"="WORLD","WORLD BLACK"="WORLD", "WORLD ELITE"="WORLD","WORLD BLACK EDITION"="WORLD","NEW WORLD"="WORLD",
                             "STANDARD"="STANDARD","STANDARD UNEMBOSSED"="STANDARD","CLASSIC"="STANDARD"," ELECTRON"="STANDARD",
                             "GOLD"="GOLD",
                             "PREPAID"="PREPAID","PREPAID PLATINUM"="PREPAID","PREPAID RELOADABLE"="PREPAID",
                             "BUSINESS"="BUSINESS","CORPORATE T&E"="BUSINESS",
                             .default = "other")
proba_uczaca$description <- recode(proba_uczaca$description,
                             "platnosci za faktury za tv internet telefon"="Telekomunikacja","Orange Flex"="Telekomunikacja", "Orange On-line:"="Telekomunikacja","PLAY - FAKTURA"="Telekomunikacja","RedBull Mobile - FAKTURA"="Telekomunikacja",
                             "iTaxi"="Transport","Przejazd A4Go"="Transport",
                             .default = "inne")

proba_uczaca$day_of_week_createtime <- recode(proba_uczaca$day_of_week_createtime,
                                              "poniedziałek" = "poniedziałek", "wtorek" = "wtorek",
                                              "środa" = "środa", "czwartek" = "czwartek",
                                              "piątek" = "piątek", .default = "weekend")

proba_uczaca$quarter_createtime <- recode(proba_uczaca$month_createtime,
                                              "styczeń" = "I kwartał", "luty" = "I kwartał",
                                              "marzec" = "I kwartał", "kwiecień" = "II kwartał",
                                              "maj" = "II kwartał","czerwiec" = "II kwartał","lipiec" = "III kwartał","sierpień" = "III kwartał","wrzesień" = "III kwartał", .default = "IV kwartał")
```

# Usuwanie kolumn uznanych za nieistotne dla modelu predykcyjnego/klasyfikującego
```{r}
proba_uczaca <- subset(proba_uczaca, select = -c(screenheight, screenwidth,payclickedtime,expirymonth,expiryyear,createtime,countrycode,listtype, browseragent, id, initialtransaction_id))
```

# Sprawdzanie braków danych po obróbce danych
```{r}
missing_data_plot <- aggr(proba_uczaca, col=c('forestgreen','firebrick1'),
                          numbers=TRUE, sortVars=TRUE,
                          labels=names(proba_uczaca), cex.axis=.7,
                          gap=3, ylab=c("Missing data","Pattern"))

```

# Usunięcie zmiennej `month_createtime`, ponieważ została ona zamieniona na `quarter_createtime`
```{r}
proba_uczaca <- subset(proba_uczaca, select = -c(month_createtime))
```

## Zbiór danych po grupowaniu zmiennych
```{r data_presetation}
create_plot <- function(variable) {
  ggplot(proba_uczaca , aes(x=factor(variable), fill=factor(variable))) + 
    geom_bar() +
    theme(legend.position="none",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  
}


create_plot(proba_uczaca$issuer)
table(proba_uczaca$issuer)

create_plot(proba_uczaca$mccname)
table(proba_uczaca$mccname)

create_plot(proba_uczaca$recurringaction)
table(proba_uczaca$recurringaction)

create_plot(proba_uczaca$type)
table(proba_uczaca$type)

create_plot(proba_uczaca$description)
table(proba_uczaca$description)

create_plot(proba_uczaca$level)
table(proba_uczaca$level)

create_plot(proba_uczaca$status)
table(proba_uczaca$status)

#create_plot(proba_uczaca$countrycode)
#table(proba_uczaca$countrycode)

#create_plot(proba_uczaca$listtype)
#table(proba_uczaca$listtype)

create_plot(proba_uczaca$acquirerconnectionmethod)
table(proba_uczaca$acquirerconnectionmethod)

create_plot(proba_uczaca$day_of_week_createtime)
table(proba_uczaca$day_of_week_createtime)

create_plot(proba_uczaca$quarter_createtime)
table(proba_uczaca$month_createtime)

create_plot(proba_uczaca$expirydate)
table(proba_uczaca$expirydate)

create_plot(proba_uczaca$year_createtime)
table(proba_uczaca$year_createtime)
```

#Utworzenie drzewa klasyfikacyjnego dla zmiennej `status`
```{r tree_classifier NA}
drzewo <- rpart(
  formula = status ~ .,
  data = proba_uczaca,
)

drzewo

summary(drzewo)
```

# Rysunek drzewa klasyfikacyjnego uproszczonego dla zmiennej `status`
```{r}
rpart.plot(x= drzewo,
           box.palette = "Red",
           branch.type = 5)
```

# Utworzenie pełnego drzewa klasyfikacyjnego dla zmiennej `status`
```{r}
drzewo.duze <- rpart(
  formula = status ~ .,
  data = proba_uczaca,
  control = rpart.control(cp=0)
)
```

# Rysunek pełnego drzewa klasyfikacyjnego dla zmiennej `status` oraz drzewa optymalnego
```{r}
bledy <- drzewo.duze$cptable
rpart.plot(x=drzewo.duze)

nr.min.cp <- which.min(bledy[, "xerror"])  # numer min cp w sprawdzaniu krzyżowym
tmp2 <- sum(bledy[nr.min.cp, c("xerror", "xstd")]) # min błąd + odchylenie standardowe
optymalny <- which(bledy[, "xerror"] < tmp2)[1] # nr optymalnego drzewa

drz.veh.p <- prune(drzewo.duze, cp = bledy[optymalny, "CP"]) # przycięcie drzewa
rpart.plot(drz.veh.p)
```

```{r tree_describe NA, echo=FALSE,  message = FALSE, warning = FALSE}
# rpart.rules(
#   x = drz.veh.p,
#   style = "tallw"
# )
# levels(proba_uczaca$status)
# reguly <- rpart.rules(x= drz.veh.p)
# 
# summary(drz.veh.p)
```


## Drzewo regresyjne
```{r}
# Model drzewa regresyjnego
drzewo_przeuczone <- rpart(
  formula = amount ~.,
  data= proba_uczaca,
  )

dim(drzewo_przeuczone$cptable)

# Narysować wykres drzewa
rpart.plot(drzewo_przeuczone
           ,branch.type = 5)
rpart.rules(drzewo_przeuczone,style="tallw")
# Przestudiować proces budowy drzewa
summary(drzewo_przeuczone)
# Odczytać ważność zmiennych
cbind(drzewo$variable.importance *100 / ss(gd$WYD))
# Ustalić optymalną wielkość drzewa na podstawie sprawdzania krzyżowego
przycinanie <- function(drzewo) {
  bledy <- drzewo$cptable
  tmp1 <- which.min(bledy[, "xerror"])  # min błąd w sprawdzaniu krzyżowym
  tmp2 <- sum(bledy[tmp1, c("xerror", "xstd")]) # min błąd + odchylenie standardowe
  optymalny <- which(bledy[, "xerror"] < tmp2)[1] # nr optymalnego drzewa
  
  prune(drzewo, cp = bledy[optymalny, "CP"]) # przycięcie drzewa
}
# Ocenić dokładność modelu

drzewo_przyciete <- przycinanie(drzewo_przeuczone)
drzewo_przyciete$cptable

predykcje <- predict(drzewo_przyciete)

mean((gd$WYD - predykcje)^2)^0.5


plot(x=gd$WYD,y=predykcje)

table(predykcje)
```